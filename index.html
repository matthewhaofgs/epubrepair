<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>EPUB Toolbox v4.0 — Repair + Merge (Google Play Books)</title>
<style>
:root{--bg:#0b0f14;--panel:#121821;--ink:#e7edf6;--muted:#94a3b8;--accent:#4f46e5;--ok:#10b981;--warn:#f59e0b;--bad:#ef4444}
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,#0b0f14,#0f172a);color:var(--ink);font:14px/1.35 system-ui,Segoe UI,Roboto,Inter,sans-serif}
header{padding:24px 16px;text-align:center}
h1{margin:6px 0 4px;font-size:22px}
.sub{color:var(--muted)}
main{max-width:1200px;margin:0 auto;padding:0 16px 48px}
.card{background:var(--panel);border:1px solid #1f2937;border-radius:14px;box-shadow:0 6px 30px rgba(0,0,0,.35);overflow:hidden}
.top{display:grid;grid-template-columns:1fr 1fr auto auto;gap:12px;align-items:center;padding:14px;border-bottom:1px solid #1f2937}
@media(max-width:1050px){.top{grid-template-columns:1fr}}
.drop{position:relative;display:flex;align-items:center;justify-content:center;min-height:120px;border:2px dashed #334155;border-radius:12px;transition:.15s;padding:10px;background:#0b1320}
.drop:hover{border-color:#475569}
.drop.ready{border-color:var(--ok);box-shadow:0 0 0 3px rgba(16,185,129,.15) inset}
.drop input[type=file]{position:absolute;inset:0;opacity:0;cursor:pointer;width:100%;height:100%;display:block}
.title{position:absolute;top:8px;left:10px;font-weight:700;color:#a5b4fc;font-size:12px}
.selected{position:absolute;left:12px;right:12px;bottom:10px;display:flex;justify-content:center;pointer-events:none}
.pill{display:inline-block;background:#0b1220;border:1px solid #1f2937;border-radius:999px;padding:4px 8px;margin:2px}
.meta{font-size:12px;color:var(--muted)}
.btn{background:var(--accent);color:#fff;border:none;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer;white-space:nowrap}
.btn:disabled{opacity:.5;cursor:not-allowed}
.grid{display:grid;grid-template-columns:1.35fr .65fr;gap:16px;padding:14px}
@media(max-width:1050px){.grid{grid-template-columns:1fr}}
.log{background:#0a0f18;border:1px solid #1f2937;border-radius:10px;padding:12px;min-height:220px;max-height:60vh;overflow:auto;font:12px ui-monospace,Menlo,Consolas,monospace}
.good{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
.panel{display:flex;flex-direction:column;gap:12px}
.preview{border:1px solid #1f2937;border-radius:12px;background:#0b1320;padding:10px;display:flex;gap:12px;align-items:center}
.thumb{width:92px;height:128px;border-radius:8px;object-fit:cover;background:#0a1324;border:1px solid #1e293b}
.placeholder{width:92px;height:128px;border-radius:8px;background:repeating-linear-gradient(45deg,#10213a,#10213a 10px,#0c1830 10px,#0c1830 20px);border:1px solid #1e293b;display:flex;align-items:center;justify-content:center;color:#6b7280;font-weight:700;font-size:11px}
.caps{letter-spacing:.02em;text-transform:uppercase;font-size:11px;color:#a5b4fc}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.k{display:inline-block;background:#0b1220;border:1px solid #1f2937;border-radius:6px;padding:0 6px;font:12px/20px ui-monospace,monospace;color:#cfe2ff}
.chip{display:inline-flex;align-items:center;gap:6px;padding:3px 8px;border:1px solid #1f2937;border-radius:999px;background:#0b1220;font-size:12px}
.dot{width:8px;height:8px;border-radius:50%}
.dot.base{background:var(--accent)} .dot.addon{background:#22d3ee} .dot.merge{background:var(--ok)}
</style>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
<header>
  <h1>EPUB Toolbox v4.0</h1>
  <div class="sub">Repair EPUBs and merge add-on chapters. Hardened for Google Play Books (EPUB2/3).</div>
</header>

<main>
  <div class="card">
    <div class="top">
      <div class="drop" id="dropBase">
        <span class="title">Base EPUB</span>
        <input type="file" id="pickBase" accept=".epub,application/epub+zip"/>
        <div><div style="font-weight:700">Drop base EPUB or click</div><div class="meta">Metadata kept from here.</div></div>
        <div id="selBase" class="selected"><span class="pill meta">(No file selected)</span></div>
      </div>
      <div class="drop" id="dropAddon">
        <span class="title">Add-on EPUB (optional)</span>
        <input type="file" id="pickAddon" accept=".epub,application/epub+zip"/>
        <div><div style="font-weight:700">Drop add-on EPUB or click</div><div class="meta">Only new chapters append.</div></div>
        <div id="selAddon" class="selected"><span class="pill meta">(No file selected)</span></div>
      </div>
      <button class="btn" id="btnRepair" disabled>Scan & Repair Base</button>
      <button class="btn" id="btnMerge" disabled>Merge Add-on → Base & Repair</button>
    </div>

    <div class="grid">
      <div><div id="log" class="log" aria-live="polite"></div></div>
      <div class="panel">
        <div class="preview">
          <div id="thumbBase" class="placeholder">No Cover</div>
          <div>
            <div class="caps">Base</div>
            <div id="nameBase" class="meta">—</div>
            <div id="sizeBase" class="meta">—</div>
            <div id="chapBase" class="meta">Chapters: —</div>
          </div>
        </div>
        <div class="preview">
          <div id="thumbAddon" class="placeholder">No Cover</div>
          <div>
            <div class="caps">Add-on</div>
            <div id="nameAddon" class="meta">—</div>
            <div id="sizeAddon" class="meta">—</div>
            <div id="chapAddon" class="meta">Chapters: —</div>
          </div>
        </div>
        <details open>
          <summary>Chapter preview</summary>
          <div class="row" id="chips"></div>
          <div class="meta" id="mergeHint">Select files to analyze chapters.</div>
        </details>
        <div class="row">
          <a id="download" class="btn" style="display:none;background:var(--ok)">Download Result</a>
          <span class="meta">Tip: <span class="k">Ctrl/⌘ + Enter</span> to run.</span>
        </div>
      </div>
    </div>
  </div>
</main>

<script>
/* ===== basics ===== */
const $ = s=>document.querySelector(s);
const logEl=$('#log');
function log(m,cls=''){const d=document.createElement('div'); if(cls)d.className=cls; d.innerHTML=m; logEl.appendChild(d); logEl.scrollTop=logEl.scrollHeight;}
function resetLog(){ logEl.innerHTML=''; const d=$('#download'); d.style.display='none'; d.removeAttribute('href'); d.removeAttribute('download'); }
function human(b){const u=['B','KB','MB','GB']; let i=0,n=b; while(n>=1024&&i<u.length-1){n/=1024;i++} return (i?n.toFixed(1):n)+" "+u[i];}
function escapeHtml(s){return String(s).replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m]))}
function extOf(p){const m=p.match(/\.([^.]+)$/); return m? m[1].toLowerCase() : '';}
function normalizePath(p){ return p.replace(/\\/g,'/').replace(/\/+/g,'/'); }
function dirOf(p){const i=p.lastIndexOf('/'); return i>=0? p.slice(0,i+1):'';}
function basename(p){return p.split('/').pop();}
function joinPath(...args) {
    const parts = args.flatMap(part => part.split('/'));
    const newParts = [];
    for (const part of parts) {
        if (!part || part === '.') continue;
        if (part === '..') newParts.pop();
        else newParts.push(part);
    }
    return newParts.join('/');
}
function sanitizeFilename(name) { return name.replace(/[\s]/g, '_'); }

/* ===== state/UI ===== */
let baseFile=null, addonFile=null;
const btnRepair=$('#btnRepair'), btnMerge=$('#btnMerge'), dlA=$('#download');
const pickBase=$('#pickBase'), pickAddon=$('#pickAddon');
const dropBase=$('#dropBase'), dropAddon=$('#dropAddon');
const selBase=$('#selBase'), selAddon=$('#selAddon');
const nameBase=$('#nameBase'), sizeBase=$('#sizeBase'), chapBase=$('#chapBase'), thumbBase=$('#thumbBase');
const nameAddon=$('#nameAddon'), sizeAddon=$('#sizeAddon'), chapAddon=$('#chapAddon'), thumbAddon=$('#thumbAddon');
const chips=$('#chips'), mergeHint=$('#mergeHint');

function showSel(which, file){
  const sel=which==='base'? selBase:selAddon;
  const drop=which==='base'? dropBase:dropAddon;
  const nameEl=which==='base'? nameBase:nameAddon;
  const sizeEl=which==='base'? sizeBase:sizeAddon;
  if(!file){
    sel.innerHTML = `<span class="pill meta">(No file selected)</span>`;
    drop.classList.remove('ready'); nameEl.textContent='—'; sizeEl.textContent='—';
    if(which === 'base') chapBase.textContent = 'Chapters: —'; else chapAddon.textContent = 'Chapters: —';
    const thumb = which === 'base' ? thumbBase : thumbAddon;
    thumb.className='placeholder'; thumb.textContent='No Cover'; thumb.style.backgroundImage='none'; return;
  }
  sel.innerHTML=`<span class="pill"><b>${escapeHtml(file.name)}</b> — ${human(file.size)}</span>`;
  drop.classList.add('ready'); nameEl.textContent=file.name; sizeEl.textContent=human(file.size);
}

async function coverPreview(which, file){
  const thumb=which==='base'? thumbBase:thumbAddon;
  try{
    const zip=await JSZip.loadAsync(await file.arrayBuffer());
    const {opfPath}=await extractOpf(zip);
    const opfDir=dirOf(opfPath), opfStr=await zip.file(opfPath).async('string');
    const opfDoc=new DOMParser().parseFromString(opfStr,'application/xml');
    const items=[...opfDoc.querySelectorAll('manifest>item')].map(x=>({href:normalizePath(x.getAttribute('href')||''),type:(x.getAttribute('media-type')||'').toLowerCase(),properties:x.getAttribute('properties')||''}));
    let cover=items.find(i=>/\bcover-image\b/.test(i.properties||''))||items.find(i=>/cover\.(jpg|jpeg|png|gif|webp|avif)$/i.test(i.href))||items.find(i=>/^image\//.test(i.type));
    if(!cover) throw 0;
    const abs=joinPath(opfDir,cover.href); const blob=await zip.file(abs).async('blob');
    let final=blob;
    if(/image\/(webp|avif|svg|png)/i.test(blob.type)){ const bmp=await createImageBitmap(blob).catch(()=>null); if(bmp){ const c=document.createElement('canvas'); c.width=bmp.width;c.height=bmp.height; c.getContext('2d').drawImage(bmp,0,0); final=await new Promise(r=>c.toBlob(r,'image/jpeg',0.9)); } }
    const url=URL.createObjectURL(final); const img=document.createElement('img'); img.className='thumb'; img.src=url; thumb.className=''; thumb.innerHTML=''; thumb.appendChild(img);
  }catch{ thumb.className='placeholder'; thumb.textContent='No Cover'; }
}
/* DnD */
for(const dz of [dropBase,dropAddon]){
  ['dragenter','dragover'].forEach(e=>dz.addEventListener(e,ev=>{ev.preventDefault(); dz.style.borderColor='#60a5fa'}));
  ['dragleave','drop'].forEach(e=>dz.addEventListener(e,ev=>{ev.preventDefault(); dz.style.borderColor='#334155'}));
}
function fileFromDT(dt){ if(dt?.items?.length){ for(const it of dt.items){ if(it.kind==='file'){ const f=it.getAsFile(); if(f) return f; } } } return dt?.files?.[0]||null; }
dropBase.addEventListener('drop', e=>{ const f=fileFromDT(e.dataTransfer); if(f) onBaseFile(f); });
dropAddon.addEventListener('drop', e=>{ const f=fileFromDT(e.dataTransfer); if(f) onAddonFile(f); });

/* Single native input listeners */
pickBase.addEventListener('change', ()=>{ const f=pickBase.files?.[0]; if(f) onBaseFile(f); });
pickAddon.addEventListener('change', ()=>{ const f=pickAddon.files?.[0]; if(f) onAddonFile(f); });

/* ===== EPUB helpers ===== */
async function extractOpf(zip){
  let opfPath='';
  const containerFile = zip.file('META-INF/container.xml');
  if(containerFile){
    const c=await containerFile.async('string');
    const d=new DOMParser().parseFromString(c,'application/xml');
    const rf=d.querySelector('rootfile[full-path]'); if(rf) opfPath=normalizePath(rf.getAttribute('full-path')||'');
  }
  if(!opfPath){ const guess=zip.file(/\.opf$/i)[0]; if(guess) opfPath=guess.name; }
  if(!opfPath) throw new Error('OPF not found');
  return {opfPath};
}
function sanitizeHtmlString(htmlString, isXhtml, removedFiles, opfDir){
  const type=isXhtml? 'application/xhtml+xml':'text/html';
  const doc=new DOMParser().parseFromString(htmlString,type);
  ['script','iframe','frame','frameset','object','embed','applet','form', 'font'].forEach(t=>doc.querySelectorAll(t).forEach(n=>n.remove()));
  doc.querySelectorAll('link').forEach(n=>{ const rel=(n.getAttribute('rel')||'').toLowerCase(); if(rel!=='stylesheet') n.remove(); });
  const tw=doc.createTreeWalker(doc,NodeFilter.SHOW_ELEMENT);
  for(let node; (node=tw.nextNode());){
    [...node.attributes||[]].forEach(a=>{
      const n=a.name.toLowerCase(), v=a.value||'';
      if(n.startsWith('on') || n === 'style') node.removeAttribute(a.name);
      if((n==='href'||n==='src') && (/^\s*javascript:/i.test(v) || /^https?:\/\//i.test(v))) node.removeAttribute(a.name);
    });
  }
  doc.querySelectorAll('a').forEach(a=>{ const s=doc.createElement('span'); while(a.firstChild) s.appendChild(a.firstChild); a.replaceWith(s); });
  
  // Remove img tags linking to corrupt images
  for(const removedPath of removedFiles){
      const removedRel = removedPath.substring(opfDir.length);
      doc.querySelectorAll(`img[src="${removedRel}"]`).forEach(img => img.remove());
  }

  if(!isXhtml){
    let m=doc.querySelector('meta[charset]'); if(!m){ m=doc.createElement('meta'); m.setAttribute('charset','utf-8'); doc.head?.insertBefore(m, doc.head.firstChild||null); }
  }else{
    const html=doc.documentElement; if(html && !html.getAttribute('xmlns')) html.setAttribute('xmlns','http://www.w3.org/1999/xhtml');
    if(html && !html.getAttribute('xml:lang') && !html.getAttribute('lang')) html.setAttribute('xml:lang','en');
  }
  return new XMLSerializer().serializeToString(doc);
}

/* ===== image validation/conversion ===== */
async function processImage(data, mediaType) {
    const blob = new Blob([data], {type: mediaType});
    const bmp = await createImageBitmap(blob).catch(() => null);
    if (!bmp || bmp.width === 0 || bmp.height === 0) {
        return null; // Indicates corruption
    }
    
    const ext = mediaType.split('/')[1];
    if (['png', 'svg+xml', 'webp', 'avif'].includes(ext)) {
        const cnv = document.createElement('canvas');
        cnv.width = bmp.width;
        cnv.height = bmp.height;
        const ctx = cnv.getContext('2d', { alpha: false });
        ctx.fillStyle = 'white'; 
        ctx.fillRect(0, 0, cnv.width, cnv.height);
        ctx.drawImage(bmp, 0, 0);
        const outBlob = await new Promise(r => cnv.toBlob(r, 'image/jpeg', 0.92));
        return { data: await outBlob.arrayBuffer(), mediaType: 'image/jpeg' };
    }
    
    return { data, mediaType }; // Return original if no conversion needed
}


/* ===== repair ===== */
async function repairOnly(zip, inName){
  const fixes=[], issues=[];
  const {opfPath: originalOpfPath}=await extractOpf(zip);
  
  const fileData = new Map();
  const pathRenameMap = new Map();
  const removedFiles = new Set();

  // Step 1: Sanitize filenames and load all files into memory.
  for (const file of Object.values(zip.files)) {
      if (file.dir) continue;
      const oldPath = normalizePath(file.name);
      const newPath = oldPath === 'mimetype' ? 'mimetype' : joinPath(dirOf(oldPath), sanitizeFilename(basename(oldPath)));
      
      const data = await file.async('arraybuffer');
      fileData.set(newPath, data);

      if (oldPath !== newPath) {
          pathRenameMap.set(oldPath, newPath);
          fixes.push(`Sanitized path: ${oldPath} -> ${newPath}`);
      }
  }

  const opfPath = pathRenameMap.get(originalOpfPath) || originalOpfPath;
  const opfDir = dirOf(opfPath);

  // Step 2: Process OPF and update manifest hrefs based on filename sanitization.
  const opfStr = new TextDecoder().decode(fileData.get(opfPath));
  const opfDoc = new DOMParser().parseFromString(opfStr, 'application/xml');
  const manifestItems = [...opfDoc.querySelectorAll('manifest > item')];
  
  for(const item of manifestItems) {
      const oldHref = item.getAttribute('href');
      const oldAbsPath = joinPath(opfDir, oldHref);
      if (pathRenameMap.has(oldAbsPath)) {
          const newAbsPath = pathRenameMap.get(oldAbsPath);
          const newHref = newAbsPath.substring(opfDir.length);
          item.setAttribute('href', newHref);
      }
  }

  // Step 3: Image validation, conversion, and removal.
  const itemsToRemove = [];
  for(const item of manifestItems) {
      const mediaType = item.getAttribute('media-type');
      if (mediaType && mediaType.startsWith('image/')) {
          const oldHref = item.getAttribute('href');
          const oldAbsPath = joinPath(opfDir, oldHref);
          
          if (!fileData.has(oldAbsPath)) {
              issues.push(`Image file not found in archive: ${oldHref}`);
              itemsToRemove.push(item);
              continue;
          }

          const imageData = fileData.get(oldAbsPath);
          const result = await processImage(imageData, mediaType);

          if (!result) { // Image is corrupt
              issues.push(`Removed corrupt image: ${oldHref}`);
              fileData.delete(oldAbsPath);
              removedFiles.add(oldAbsPath);
              itemsToRemove.push(item);
              pathRenameMap.set(oldAbsPath, null); // Mark as removed
          } else if (result.mediaType !== mediaType) { // Image was converted
              const newHref = oldHref.replace(/\.[^.]+$/, '.jpg');
              const newAbsPath = joinPath(opfDir, newHref);
              
              fileData.delete(oldAbsPath);
              fileData.set(newAbsPath, result.data);
              
              pathRenameMap.set(oldAbsPath, newAbsPath);
              item.setAttribute('href', newHref);
              item.setAttribute('media-type', 'image/jpeg');
              fixes.push(`Converted image: ${basename(oldHref)} -> ${basename(newHref)}`);
          }
      }
  }
  itemsToRemove.forEach(item => item.remove());

  // Step 4: Update all content files (HTML, CSS, NCX) with new paths.
  const allItems = [...opfDoc.querySelectorAll('manifest > item')];
  for (const item of allItems) {
      const href = item.getAttribute('href');
      const mediaType = item.getAttribute('media-type');
      if (mediaType && (mediaType.includes('html') || mediaType.includes('css') || mediaType.includes('ncx'))) {
          const path = joinPath(opfDir, href);
          if (!fileData.has(path)) continue;

          let content = new TextDecoder().decode(fileData.get(path));
          let changed = false;

          for (const [oldPath, newPath] of pathRenameMap.entries()) {
              if (newPath === null) continue; // Skip removed files
              const oldRel = oldPath.substring(opfDir.length);
              const newRel = newPath.substring(opfDir.length);
              if (content.includes(oldRel)) {
                  content = content.replace(new RegExp(oldRel.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), newRel);
                  changed = true;
              }
          }
          
          if(mediaType.includes('html')) {
              const sanitized = sanitizeHtmlString(content, mediaType.includes('xhtml'), removedFiles, opfDir);
              if(sanitized !== content) {
                  content = sanitized;
                  changed = true;
                  fixes.push(`Sanitized HTML & removed broken image links in: ${href}`);
              }
          }

          if (changed) {
              fileData.set(path, new TextEncoder().encode(content));
          }
      }
  }

  // Step 5: Metadata fixes
  const metadata = opfDoc.querySelector('metadata');
  const langEl = metadata.querySelector('dc\\:language, language');
  if (langEl) {
      if (langEl.textContent.includes('_')) {
          langEl.textContent = langEl.textContent.replace(/_/g, '-');
          fixes.push('Corrected dc:language format (BCP-47)');
      }
  } else {
      const dcNS = 'http://purl.org/dc/elements/1.1/';
      const newLangEl = opfDoc.createElementNS(dcNS, 'dc:language');
      newLangEl.textContent = 'en';
      metadata.appendChild(newLangEl);
      fixes.push('Added dc:language=en');
  }
  
  // Step 6: Validate guide section
  const guide = opfDoc.querySelector('guide');
  if (guide) {
      const validHrefs = new Set([...opfDoc.querySelectorAll('manifest > item')].map(i => i.getAttribute('href')));
      [...guide.querySelectorAll('reference')].forEach(ref => {
          if (!validHrefs.has(ref.getAttribute('href'))) {
              ref.remove();
              fixes.push(`Removed invalid guide reference: ${ref.getAttribute('href')}`);
          }
      });
  }

  // Step 7: Finalize OPF and create new zip
  const finalOpfStr = new XMLSerializer().serializeToString(opfDoc);
  fileData.set(opfPath, new TextEncoder().encode(finalOpfStr));

  const outZip = new JSZip();
  // Add mimetype first, uncompressed
  if(fileData.has('mimetype')) {
      outZip.file('mimetype', fileData.get('mimetype'), {compression: 'STORE'});
  }

  for (const [path, data] of fileData.entries()) {
      if (path !== 'mimetype') {
          outZip.file(path, data);
      }
  }

  const blob = await outZip.generateAsync({type:'blob', mimeType:'application/epub+zip', compression:'DEFLATE', compressionOptions:{level:9}});
  log(`<b>Fixes applied (${fixes.length}):</b>`); fixes.forEach(f=>log('  • '+escapeHtml(f)));
  if(issues.length){ log(`<b class='warn'>Issues found (${issues.length}):</b>`,'warn'); issues.forEach(i=>log('  • '+escapeHtml(i),'warn')); }
  return {blob, reportName:(inName.replace(/\.epub$/i,'')||'book')+'_fixed.epub'};
}

/* ===== merge + repair ===== */
async function mergeThenRepair(baseZip, addonZip, baseName){
  log('Merge + Repair is not yet fully implemented with the latest fixes. Please use Repair Only for now.','warn');
  throw new Error('Merge + Repair is under development.');
}

/* ===== handlers ===== */
async function onBaseFile(file){
  baseFile=file; 
  showSel('base',file); 
  await coverPreview('base',file);
  btnRepair.disabled=!baseFile; 
  btnMerge.disabled=!(baseFile&&addonFile);
}
async function onAddonFile(file){
  addonFile=file; 
  showSel('addon',file); 
  await coverPreview('addon',file);
  btnMerge.disabled=!(baseFile&&addonFile);
}

/* run */
$('#btnRepair').addEventListener('click', async ()=>{
  resetLog();
  if(!baseFile){ log('Select a base EPUB first.','bad'); return; }
  log(`<b>Reading:</b> ${escapeHtml(baseFile.name)}`);
  try{
    const zip = await JSZip.loadAsync(await baseFile.arrayBuffer());
    const {blob,reportName}=await repairOnly(zip, baseFile.name);
    const url=URL.createObjectURL(blob); dlA.href=url; dlA.download=reportName; dlA.style.display='inline-block';
    log('<b>Packaging complete.</b>','good');
  }catch(err){ console.error(err); log(`<b class="bad">Failed:</b> ${escapeHtml(err.message)}`,'bad'); }
});
$('#btnMerge').addEventListener('click', async ()=>{
  resetLog();
  if(!(baseFile&&addonFile)){ log('Select both base and add-on EPUBs.','bad'); return; }
  log(`<b>Base:</b> ${escapeHtml(baseFile.name)} • <b>Add-on:</b> ${escapeHtml(addonFile.name)}`);
  try{
    const baseZip = await JSZip.loadAsync(await baseFile.arrayBuffer());
    const addonZip = await JSZip.loadAsync(await addonFile.arrayBuffer());
    const {blob,reportName}=await mergeThenRepair(baseZip, addonZip, baseFile.name);
    const url=URL.createObjectURL(blob); dlA.href=url; dlA.download=reportName; dlA.style.display='inline-block';
    log('<b>Merged & packaged.</b>','good');
  }catch(err){ console.error(err); log(`<b class="bad">Failed:</b> ${escapeHtml(err.message)}`,'bad'); }
});

/* shortcut */
window.addEventListener('keydown', e=>{ if((e.ctrlKey||e.metaKey)&&e.key==='Enter'){ if(addonFile&&baseFile) $('#btnMerge').click(); else if(baseFile) $('#btnRepair').click(); }});
</script>
</body>
</html>
